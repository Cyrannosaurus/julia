// DO NOT EDIT! This file is automatically generated by llvm-dialects-tblgen.


#ifdef GET_INCLUDES
#undef GET_INCLUDES
#include "llvm-dialects/Dialect/Builder.h"
#include "llvm-dialects/Dialect/OpDescription.h"
#include "llvm-dialects/Dialect/Utils.h"
#include "llvm-dialects/Dialect/Verifier.h"
#include "llvm-dialects/Dialect/Visitor.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/IR/InstrTypes.h"

#include "llvm/Support/ModRef.h"

#include "llvm/Support/raw_ostream.h"
#endif // GET_INCLUDES

#ifdef GET_DIALECT_DEFS
#undef GET_DIALECT_DEFS
namespace julia {

    void JuliaDialect::anchor() {}

    ::llvm_dialects::Dialect::Key& JuliaDialect::getKey() {
      static Key s_key;
      return s_key;
    }

    ::llvm_dialects::Dialect* JuliaDialect::make(::llvm::LLVMContext& context) {
      
      auto verifierBuild = [](::llvm_dialects::VisitorBuilder<::llvm_dialects::VerifierState> &builder) {
    
        builder.add<GetPGCStack>([](::llvm_dialects::VerifierState &state, GetPGCStack &op) {
          if (!op.verifier(state.out()))
            state.setError();
        });
      
      };
      static const ::llvm_dialects::VerifierExtension verifierExtension = {
        verifierBuild,
      };
      static ::llvm_dialects::DialectExtensionRegistration<::llvm_dialects::VerifierExtension, JuliaDialect>
          verifierExtensionRegistration(::llvm_dialects::getVerifierExtensionPoint(), &verifierExtension);
    
      return new JuliaDialect(context);
    }

    JuliaDialect::JuliaDialect(::llvm::LLVMContext& context) : DialectImpl(context) {
  {
  ::llvm::AttrBuilder attrBuilder{context};
attrBuilder.addAttribute(::llvm::Attribute::NoUnwind);
attrBuilder.addMemoryAttr(::llvm::MemoryEffects(::llvm::MemoryEffects::Location::InaccessibleMem, ::llvm::ModRefInfo::Ref));
m_attributeLists[0] = ::llvm::AttributeList::get(context, ::llvm::AttributeList::FunctionIndex, attrBuilder);
}
}

JuliaValue* JuliaValue::get(::llvm::LLVMContext & ctx) {
::std::array<::llvm::Type *, 0> types = {

    };
    ::std::array<unsigned, 0> ints = {
  
      };

      auto *type = ::llvm::cast<JuliaValue>(::llvm::TargetExtType::get(ctx, s_name, types, ints));
      assert(::llvm_dialects::runTypeVerifier([type](llvm::raw_ostream &errs) {
        return type->verifier(errs);
      }, type));
      return type;
    }
  
    bool JuliaValue::verifier(::llvm::raw_ostream &errs) const {
      ::llvm::LLVMContext &ctx = getContext();
      (void)ctx;

      using ::llvm_dialects::printable;

      if (getNumTypeParameters() != 0) {
        errs << "  wrong number of type parameters\n";
        errs << "    expected: 0\n";
        errs << "      actual: " << getNumTypeParameters() << '\n';
        return false;
      }

      if (getNumIntParameters() != 0) {
        errs << "  wrong number of int parameters\n";
        errs << "    expected: 0\n";
        errs << "      actual: " << getNumIntParameters() << '\n';
        return false;
      }
  return true;
}


      const ::llvm::StringLiteral GetPGCStack::s_name{"julia.get_pgcstack"};

    GetPGCStack* GetPGCStack::create(llvm_dialects::Builder& b, ::llvm::Type* resultType) {
    ::llvm::LLVMContext& context = b.getContext();
    (void)context;
    ::llvm::Module& module = *b.GetInsertBlock()->getModule();
  
  
      const ::llvm::AttributeList attrs
          = JuliaDialect::get(context).getAttributeList(0);
    auto fnType = ::llvm::FunctionType::get(resultType, {
}, false);

    auto fn = module.getOrInsertFunction(s_name, fnType, attrs);
    ::llvm::SmallString<32> newName;
    for (unsigned i = 0; !::llvm::isa<::llvm::Function>(fn.getCallee()) ||
                         ::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() != fn.getFunctionType(); i++) {
      // If a function with the same name but a different types already exists,
      // we get a bitcast of a function or a function with the wrong type.
      // Try new names until we get one with the correct type.
      newName = "";
      ::llvm::raw_svector_ostream newNameStream(newName);
      newNameStream << s_name << "_" << i;
      fn = module.getOrInsertFunction(newNameStream.str(), fnType, attrs);
    }
    assert(::llvm::isa<::llvm::Function>(fn.getCallee()));
    assert(fn.getFunctionType() == fnType);
    assert(::llvm::cast<::llvm::Function>(fn.getCallee())->getFunctionType() == fn.getFunctionType());

  return ::llvm::cast<GetPGCStack>(b.CreateCall(fn));
}


    bool GetPGCStack::verifier(::llvm::raw_ostream &errs) {
      ::llvm::LLVMContext &context = getModule()->getContext();
      (void)context;

      using ::llvm_dialects::printable;

      if (arg_size() != 0) {
        errs << "  wrong number of arguments: " << arg_size()
               << ", expected 0\n";
        return false;
      }
  ::llvm::Type * const resultType = getResult()->getType();
(void)resultType;

        if (JuliaValue::get(context) != resultType) {
          errs << "  unexpected value of $result:\n";
          errs << "    expected:  " << printable(JuliaValue::get(context)) << '\n';
          errs << "    actual:    " << printable(resultType) << '\n';
        
          return false;
        }
        return true;
}


::llvm::Value *GetPGCStack::getResult() {return this;}


} // namespace julia

      template <>
      const ::llvm_dialects::OpDescription &
      ::llvm_dialects::OpDescription::get<julia::GetPGCStack>() {
        static const ::llvm_dialects::OpDescription desc{false, "julia.get_pgcstack"};
        return desc;
      }

    
#endif // GET_DIALECT_DEFS
